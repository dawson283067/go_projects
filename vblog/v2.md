# vblog项目重构 v2

## v1的问题

v1：
+ UserServiceImpl
+ TokenServiceImpl
+ TokenApiHandler

```go
package main

import (
	"github.com/gin-gonic/gin"
	"github.com/go_projects/vblog/apps/token/api"
	token_impl "github.com/go_projects/vblog/apps/token/impl"
	user_impl "github.com/go_projects/vblog/apps/user/impl"
)

func main() {

	// user service impl
	usvc := user_impl.NewUserServiceImpl()

	// token service impl
    tsvc := token_impl.NewTokenServiceImpl(usvc)

	// api
	TokenApiHandler := api.NewTokenApiHandler(tsvc)

	// Protocol
	engine := gin.Default()

	rr := engine.Group("/vblog/api/v1")
	TokenApiHandler.Registry(rr)

	// 把Http协议服务器启动起来
	if err := engine.Run(":8080"); err != nil {
		panic(err)
	}

}
```

当模块众多的时候，main里面 手动组装对象的难度会越来越大

## ioc: 依赖反转

控制反转（inversion of control, ioc）

![](./docs/ioc.drawio)

```go
1. 注册对象（采用 init()导入的方式来执行注册）

_ "github.com/go_projects/vblog/apps/token/api"
_ "github.com/go_projects/vblog/apps/token/impl"
_ "github.com/go_projects/vblog/apps/user/impl"

ioc.Registry("user_servie_impl", &UserServiceImpl{})
ioc.Registry("token_service_impl", &TokenServiceImpl{})
ioc.Registry(&TokenApiHandler{})

2. 没有依赖关系的管理，每个对象自己去ioc获取自己的依赖
// 怎么实现token.Service接口？
// 定义TokenServiceImpl来实现接口
type TokenServiceImpl struct {
	// 依赖了一个数据库操作的连接池对象
	db *gorm.DB

	// 额外需要依赖user.Service
	// 没有 UserServiceImpl 的具体实现，这样就不跟具体的实现挂钩
	// 依赖接口，不要依赖接口的具体实现
	// 实现的时候是由组装的程序给你实现是什么，比如说main程序
	user user.Service
}

// 依赖的关系解决 分成2个阶段，一个注册，一个初始化（组件完善自己的依赖关系）
func (i *TokenServiceImpl) init() {
    // 先通过ioc获取对象，然后再把对象断言成 你需要的接口
    // tsvc := token_impl.NewTokenServiceImpl(usvc) 都不需要了
    i.user = ioc.Get("user_service_impl").(user.Service)
}

3. ioc 来完成对象的初始化，让每个注册的对象，去完成依赖的自主寻找
ioc.InitAllObject()
```

4. 每写一个对象就注册一个对象，参考mcenter的具体做法
```go

```


## ioc 具体实现

使用 map[string]Object 来实现一个简易版本的ioc

[Ioc 实现](./ioc/README.md)

## ioc 改造

+ 完成队形的注册和对象的依赖获取（Init）
+ 使用ioc管理对象

### 改造控制器

改造之前：token(controller) ----> user(controller)
```go
	// user service impl
	usvc := user_impl.NewUserServiceImpl()

	// token service impl
    tsvc := token_impl.NewTokenServiceImpl(usvc)
```

改造后：
1, UserServiceImpl 对象注册
```go
// 通过 import 自动完成注册
// 为什么不能直接在这里把db对象初始化了？
// 这个逻辑是在import时执行的，程序在import后才执行的配置模块加载，此时的conf.C()为null
// 这个db属性的初始化一定要在配置加载后执行：conf.Load(), ioc.Init()
func init() {
	ioc.Controller().Registry(user.AppName, &UserServiceImpl{})
}
```

2, TokenServiceImpl 对象注册：ioc.Init() 来执行依赖获取
```go
func init() {
	ioc.Controller().Registry(token.AppName, &TokenServiceImpl{})
}

// 对象属性初始化
func (i *TokenServiceImpl) Init() error {
	// 凡是结构体属性需要补充的，都需要在这里去做
	// 依赖关系先在import里解决，然后这里初始化对象是没有问题的
	i.db = conf.C().DB()
	// 这句的语法没看懂......
	i.user = ioc.Controller().Get(user.AppName).(user.Service)
	return nil
}
```

### 改造Api

改造之前：token(api) ----> token(controller)
```go
	// token service impl
    tsvc := token_impl.NewTokenServiceImpl(usvc)

	// api
	TokenApiHandler := api.NewTokenApiHandler(tsvc)
```

改造之后：TokenApiHandler的注册，ioc.Init()来执行依赖获取
```go
func init() {
	ioc.Api().Registry(token.AppName, &TokenApiHandler{})
}

func (h *TokenApiHandler) Init() error {
	// 从Controller空间中获取模块的具体实现
	// 断言该是按是满足该接口的
	h.svc = ioc.Controller().Get(token.AppName).(token.Service)
	return nil
}
```

## 基于ioc的启动

之前的启动方法：
```go
func main() {

	// user service impl
	usvc := user_impl.NewUserServiceImpl()

	// token service impl
    tsvc := token_impl.NewTokenServiceImpl(usvc)

	// api
	TokenApiHandler := api.NewTokenApiHandler(tsvc)

	// Protocol
	engine := gin.Default()

	rr := engine.Group("/vblog/api/v1")
	TokenApiHandler.Registry(rr)

	// 把Http协议服务器启动起来
	if err := engine.Run(":8080"); err != nil {
		panic(err)
	}
}
```

之后的代码：
```go
package main

import (
	"github.com/gin-gonic/gin"
	"github.com/go_projects/vblog/apps/token"
	"github.com/go_projects/vblog/apps/token/api"
	"github.com/go_projects/vblog/conf"
	"github.com/go_projects/vblog/ioc"

	// 通过import方法 完成注册
	_ "github.com/go_projects/vblog/apps/token/api"
	_ "github.com/go_projects/vblog/apps/token/impl"
	_ "github.com/go_projects/vblog/apps/user/impl"
)

func main() {

	// 1. 初始化程序配置，这里没有配置，使用默认值
	if err := conf.LoadFromEnv(); err != nil {
		panic(err)
	}

	// 2. 程序对象管理
	if err := ioc.Init(); err != nil {
		panic(err)
	}

	// Protocol
	engine := gin.Default()

	rr := engine.Group("/vblog/api/v1")

	// ioc能不能帮忙把模块Api的注册页一起管理
	// ioc.Init()，对象初始化完成后，如果对象是 api对象，就帮忙完成下注册
	// ioc.RegistryGin(rr)？ 就是ioc里执行这个操作
	ioc.Api().Get(token.AppName).(*api.TokenApiHandler).Registry(rr)

	// 把Http协议服务器启动起来
	if err := engine.Run(":8080"); err != nil {
		panic(err)
	}
}

```

## ioc 通用功能管理（切面管理）

```go
type GinApi interface {
	// 基础约束
	Object
	// 额外约束
	// ioc.Api().Get(token.AppName).(*api.TokenApiHandler).Registry(rr)
	Registry(rr gin.IRouter)
}

// 遍历所有的对象，帮忙完成Api的注册
// 由ioc调用对象提供的Registry方法，来把模块的api 注册给gin root router
func (c *NamespaceContainer) RegistryGinApi(rr gin.IRouter) {
	// 遍历Namespace
	for key := range c.ns {
		c := c.ns[key]
		// 遍历Namespace里面的对象
		for objectName := range c.storage {
			obj := c.storage[objectName]
			// 如果判断一个对象不是GinApi对象（约束）
			// 判断对象有没有Registry(rr gin.IRouter)
			// 断言该对象 满足GinApi接口，实现了Registry函数
			if v, ok := obj.(GinApi); ok {
				v.Registry(rr)
			}
		}
	}
}
```

改造后，我们只需要完成业务对象注册，其他操作，ioc帮忙进行管理
```go
func main() {

	// 1. 初始化程序配置，这里没有配置，使用默认值
	if err := conf.LoadFromEnv(); err != nil {
		panic(err)
	}

	// 2.1 先注册对象


	// 2.2 程序对象管理
	if err := ioc.Init(); err != nil {
		panic(err)
	}

	/* v2版，这里都不要了
	// user service impl
	usvc := user_impl.NewUserServiceImpl()

	// token service impl
    tsvc := token_impl.NewTokenServiceImpl(usvc)

	// api
	TokenApiHandler := api.NewTokenApiHandler(tsvc)
	*/

	// Protocol
	engine := gin.Default()

	rr := engine.Group("/vblog/api/v1")
	// 改造之前：TokenApiHandler.Registry(rr)
	// 改造之后第一版：ioc.Api().Get(token.AppName).(*api.TokenApiHandler).Registry(rr)
	ioc.RegistryGinApi(rr)

	// 把Http协议服务器启动起来
	if err := engine.Run(":8080"); err != nil {
		panic(err)
	}
}
```

+ 1. 注册对象
+ 2. ioc管理

通过 导入 "github.com/go_projects/vblog/apps" 来导入所有的业务实现
```go
package apps

// 注册业务实现：API + Controller
// 像插件一样可以替换
import (
	// 通过import方法 完成注册
	_ "github.com/go_projects/vblog/apps/token/api"
	_ "github.com/go_projects/vblog/apps/token/impl"
	_ "github.com/go_projects/vblog/apps/user/impl"
)
```

入口就不需要修改：
```go
package main

import (
	"github.com/gin-gonic/gin"
	"github.com/go_projects/vblog/conf"
	"github.com/go_projects/vblog/ioc"	

	// 通过import方法 完成注册
	// 这样写，就不用再动main这里的代码了。将注册放到apps包下的init.go文件中
	_ "github.com/go_projects/vblog/apps"
)

func main() {

	// 1. 初始化程序配置，这里没有配置，使用默认值
	if err := conf.LoadFromEnv(); err != nil {
		panic(err)
	}

	// 2.1 先注册对象


	// 2.2 程序对象管理
	if err := ioc.Init(); err != nil {
		panic(err)
	}

	/* v2版，这里都不要了
	// user service impl
	usvc := user_impl.NewUserServiceImpl()

	// token service impl
    tsvc := token_impl.NewTokenServiceImpl(usvc)

	// api
	TokenApiHandler := api.NewTokenApiHandler(tsvc)
	*/

	// Protocol
	engine := gin.Default()

	rr := engine.Group("/vblog/api/v1")
	// 改造之前：TokenApiHandler.Registry(rr)
	// 改造之后第一版：ioc.Api().Get(token.AppName).(*api.TokenApiHandler).Registry(rr)
	ioc.RegistryGinApi(rr)

	// 把Http协议服务器启动起来
	if err := engine.Run(":8080"); err != nil {
		panic(err)
	}
}

```

有了iod后，我们业务开发流程，编写：
+ api对象
+ contriller对象

基于这个逻辑开始编写blog模块

## 基于ioc blog模块

### 定义blog业务（Define）

```go
// Blog Service接口定义，CRUD
type Service interface {
	// 创建一个博客
	CreateBlog(context.Context, *CreateBlogRequest) (*Blog, error)
	// 获取博客列表
	QueryBlog(context.Context, *QueryBlogRequest) (*BlogSet, error)
	// 获取博客详情
	DescribeBlog(context.Context, *DescribeBlogReqeust) (*Blog, error)
	// 更新博客
	UpdateBlog(context.Context, *UpdateBlogRequest) (*Blog, error)
	// 删除博客
	// 为了与GRPC保持一致，返回一个删除的对象
	DeleteBlog(context.Context, *DeleteBlogReqeust) (*Blog, error)
	// 文章状态修改，比如发布
	ChangedBlogStatus(context.Context, *ChangedBlogStatus) (*Blog, error)
	// 文章审核
	AuditBlog(context.Context, *AuditInfo) (*Blog, error)
}
```

### 实现业务（Controller）

1，定义对象
```go
func init() {
	ioc.Controller().Registry(blog.AppName, &blogServiceImpl{})
}

// blog.Service接口，是直接注册给ioc，不需要对暴露
type blogServiceImpl struct {
	// 依赖了一个数据库操作的链接池对象
	db *gorm.DB
}

func (i *blogServiceImpl) Init() error {
	i.db = conf.C().DB()
	return nil
}

func (i *blogServiceImpl) Destroy() error {
	return nil
}
```

2, 托管对象
```go
// 注册业务实现：API + Controller
import (
	// 通过import方法 完成注册
	_ "github.com/go_projects/vblog/apps/blog/impl"
)
```

3, 对象的业务接口实现
```go
import (
	"context"

	"github.com/go_projects/vblog/apps/blog"
)

// 创建一个博客
func (i *blogServiceImpl) CreateBlog(ctx context.Context, req  *blog.CreateBlogRequest) (*blog.Blog, error) {
	return nil, nil
}
// 获取博客列表
func (i *blogServiceImpl) QueryBlog(ctx context.Context, req *blog.QueryBlogRequest) (*blog.BlogSet, error) {
	return nil, nil
}
// 获取博客详情
func (i *blogServiceImpl) DescribeBlog(ctx context.Context, req *blog.DescribeBlogReqeust) (*blog.Blog, error) {
	return nil, nil
}
// 更新博客
func (i *blogServiceImpl) UpdateBlog(ctx context.Context, req *blog.UpdateBlogRequest) (*blog.Blog, error) {
	return nil, nil
}
// 删除博客
// 为了与GRPC保持一致，返回一个删除的对象
func (i *blogServiceImpl) DeleteBlog(ctx context.Context, req *blog.DeleteBlogReqeust) (*blog.Blog, error) {
	return nil, nil
}
// 文章状态修改，比如发布
func (i *blogServiceImpl) ChangedBlogStatus(ctx context.Context, req *blog.ChangedBlogStatus) (*blog.Blog, error) {
	return nil, nil
}
// 文章审核
func (i *blogServiceImpl) AuditBlog(ctx context.Context, req *blog.AuditInfo) (*blog.Blog, error) {
	return nil, nil
}
```

4.1, 编写单元测试：准备被测试的对象

```go
package impl_test

import (
	"github.com/go_projects/vblog/apps/blog"
	"github.com/go_projects/vblog/ioc"

	// 1. 加载对象
	_ "github.com/go_projects/vblog/apps"
)

// blog service 的实现的具体对象是在ioc中
// 需要在ioc中获取具体的svc 用来测试

var (
	impl blog.Service
)

func init() {
	// 2. ioc获取对象
	impl = ioc.Controller().Get(blog.AppName).(blog.Service)

	// ioc需要初始化才能填充db属性
	if err := ioc.Init(); err != nil {
		panic(err)
	}
}
```

4.2, 编写单元测试：测试接口实现
```go
import (
	"testing"

	"github.com/go_projects/vblog/apps/blog"
)

func TestCreatBlog(t *testing.T) {
	req := blog.NewCreateBlogRequest()
	req.Title = "go语言全栈开发"
    req.Author = "oldyu"
	req.Content = "xxx"
	req.Summary = "xx"
	req.Tags["目录"] = "Go语言"
	ins, err := impl.CreateBlog(ctx, nil)
	if err != nil {
		t.Fatal(err)
	}
	t.Log(ins)
}
```

```go
// 创建一个博客
func (i *blogServiceImpl) CreateBlog(ctx context.Context, req *blog.CreateBlogRequest) (*blog.Blog, error) {
	// 1. 校验请求
	if err := req.Validate(); err != nil {
		return nil, exception.ErrBadRequest.WithMessagef("创建博客失败，%s", err)
	}
	req.Validate()

	// 2. 构造对象
	ins := blog.NewBlog(req)

	// 3. 对象入库
	// INSERT INTO `blogs` (`created_at`,`updated_at`,`title`,`author`,`content`,`summary`,`create_by`,`tags`,`published_at`,`status`,`audit_at`,`is_audit_pass`) VALUES (1706933718,1706933718,'go语言全栈开发','oldyu','xxx','xx','','{"目录":"Go语言"}',0,'0',0,false)
	err := i.db.WithContext(ctx).Create(ins).Error
	if err != nil {
		return nil, err
	}

	// 4. 返回对象
	return ins, err
	
	// fmt.Println("CreateBlog")
}
```
关于Mergo
```go
// 更新博客
// 1, 全量更新：对象的替换
// 2, 部分更新：(old obj)Patch机制 --> new obj --> save
func (i *blogServiceImpl) UpdateBlog(ctx context.Context, req *blog.UpdateBlogRequest) (*blog.Blog, error) {
	// 查询老的对象，需要被更新的博客对象
	ins, err :=	i.DescribeBlog(ctx, blog.NewDescribeUserRequest(req.Id))
	if err != nil {
		return nil, err
	}

	switch req.UpdateMode {
	case common.UPDATE_MODE_PATCH:
		// if req.Author != "" {
		// 	ins.Author = req.Author
		// }
		// if req.Title != "" {
		// 	ins.Title = req.Title
		// }
		// ... 有没有其他的方法 帮我们完成2个结构体的合并 merge(patch)
		// https://github.com/darcio/mergo
		// // WithOverride will make merge override non-empty dst attribues with non-empty src attributes values.
		if err := mergo.MapWithOverwrite(ins.CreateBlogRequest, req.CreateBlogRequest); err != nil {
			return nil, err
		}
	default:
		// 按道理应该是 *CreateBlogRequest = *CreateBlogRequest
		ins.CreateBlogRequest = req.CreateBlogRequest
	}

	// 再次校验对象。有可能更新过后的数据不合法，所以校验。
	if err := ins.Validate(); err != nil {
		return nil, exception.ErrBadRequest.WithMessagef("校验更新请求失败：%s", err)
	}

	// 更新数据库
	// UPDATE `blogs` SET `id`=48,`created_at`=1707013985,`updated_at`=1707015070,`title`='go语言全栈开发V2',`author`='oldyu',`content`='xxx',`summary`='xx',`tags`='{"目录":"Go语言"}' WHERE id = 48
	err = i.db.WithContext(ctx).Model(&blog.Blog{}).Where("id = ?", ins.Id).Updates(ins).Error
	if err != nil {
		return nil, err
	}
	return ins, nil
}
```

### 暴露接口（API）

+ 创建博客：POST /vblogs/api/v1/blogs
+ 修改博客（部分）：PATCH /vblogs/api/v1/blogs/:id
+ 修改博客（全量）：PUT /vblogs/api/v1/blogs/:id
+ 删除博客：DELETE /vblogs/api/v1/blogs/:id
+ 查询列表：GET /vblogs/api/v1/blogs
+ 查询详情：GET /vblogs/api/v1/blogs/:id

### 注册业务对象





