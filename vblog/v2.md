# vblog项目重构 v2

## v1的问题

v1：
+ UserServiceImpl
+ TokenServiceImpl
+ TokenApiHandler

```go
package main

import (
	"github.com/gin-gonic/gin"
	"github.com/go_projects/vblog/apps/token/api"
	token_impl "github.com/go_projects/vblog/apps/token/impl"
	user_impl "github.com/go_projects/vblog/apps/user/impl"
)

func main() {

	// user service impl
	usvc := user_impl.NewUserServiceImpl()

	// token service impl
    tsvc := token_impl.NewTokenServiceImpl(usvc)

	// api
	TokenApiHandler := api.NewTokenApiHandler(tsvc)

	// Protocol
	engine := gin.Default()

	rr := engine.Group("/vblog/api/v1")
	TokenApiHandler.Registry(rr)

	// 把Http协议服务器启动起来
	if err := engine.Run(":8080"); err != nil {
		panic(err)
	}

}
```

当模块众多的时候，main里面 手动组装对象的难度会越来越大

## ioc: 依赖反转

控制反转（inversion of control, ioc）

![](./docs/ioc.drawio)

```go
1. 注册对象（采用 init()导入的方式来执行注册）

_ "github.com/go_projects/vblog/apps/token/api"
_ "github.com/go_projects/vblog/apps/token/impl"
_ "github.com/go_projects/vblog/apps/user/impl"

ioc.Registry("user_servie_impl", &UserServiceImpl{})
ioc.Registry("token_service_impl", &TokenServiceImpl{})
ioc.Registry(&TokenApiHandler{})

2. 没有依赖关系的管理，每个对象自己去ioc获取自己的依赖
// 怎么实现token.Service接口？
// 定义TokenServiceImpl来实现接口
type TokenServiceImpl struct {
	// 依赖了一个数据库操作的连接池对象
	db *gorm.DB

	// 额外需要依赖user.Service
	// 没有 UserServiceImpl 的具体实现，这样就不跟具体的实现挂钩
	// 依赖接口，不要依赖接口的具体实现
	// 实现的时候是由组装的程序给你实现是什么，比如说main程序
	user user.Service
}

// 依赖的关系解决 分成2个阶段，一个注册，一个初始化（组件完善自己的依赖关系）
func (i *TokenServiceImpl) init() {
    // 先通过ioc获取对象，然后再把对象断言成 你需要的接口
    // tsvc := token_impl.NewTokenServiceImpl(usvc) 都不需要了
    i.user = ioc.Get("user_service_impl").(user.Service)
}

3. ioc 来完成对象的初始化，让每个注册的对象，去完成依赖的自主寻找
ioc.InitAllObject()
```

4. 每写一个对象就注册一个对象，参考mcenter的具体做法
```go

```


## ioc 具体实现

使用 map[string]Object 来实现一个简易版本的ioc

[Ioc 实现](./ioc/README.md)

## ioc 改造

+ 完成队形的注册和对象的依赖获取（Init）
+ 使用ioc管理对象

### 改造控制器

改造之前：token(controller) ----> user(controller)
```go
	// user service impl
	usvc := user_impl.NewUserServiceImpl()

	// token service impl
    tsvc := token_impl.NewTokenServiceImpl(usvc)
```

改造后：
1, UserServiceImpl 对象注册
```go
// 通过 import 自动完成注册
// 为什么不能直接在这里把db对象初始化了？
// 这个逻辑是在import时执行的，程序在import后才执行的配置模块加载，此时的conf.C()为null
// 这个db属性的初始化一定要在配置加载后执行：conf.Load(), ioc.Init()
func init() {
	ioc.Controller().Registry(user.AppName, &UserServiceImpl{})
}
```

2, TokenServiceImpl 对象注册：ioc.Init() 来执行依赖获取
```go
func init() {
	ioc.Controller().Registry(token.AppName, &TokenServiceImpl{})
}

// 对象属性初始化
func (i *TokenServiceImpl) Init() error {
	// 凡是结构体属性需要补充的，都需要在这里去做
	// 依赖关系先在import里解决，然后这里初始化对象是没有问题的
	i.db = conf.C().DB()
	// 这句的语法没看懂......
	i.user = ioc.Controller().Get(user.AppName).(user.Service)
	return nil
}
```

### 改造Api

改造之前：token(api) ----> token(controller)
```go
	// token service impl
    tsvc := token_impl.NewTokenServiceImpl(usvc)

	// api
	TokenApiHandler := api.NewTokenApiHandler(tsvc)
```

改造之后：TokenApiHandler的注册，ioc.Init()来执行依赖获取
```go
func init() {
	ioc.Api().Registry(token.AppName, &TokenApiHandler{})
}

func (h *TokenApiHandler) Init() error {
	// 从Controller空间中获取模块的具体实现
	// 断言该是按是满足该接口的
	h.svc = ioc.Controller().Get(token.AppName).(token.Service)
	return nil
}
```

## 基于ioc的启动

之前的启动方法：
```go
func main() {

	// user service impl
	usvc := user_impl.NewUserServiceImpl()

	// token service impl
    tsvc := token_impl.NewTokenServiceImpl(usvc)

	// api
	TokenApiHandler := api.NewTokenApiHandler(tsvc)

	// Protocol
	engine := gin.Default()

	rr := engine.Group("/vblog/api/v1")
	TokenApiHandler.Registry(rr)

	// 把Http协议服务器启动起来
	if err := engine.Run(":8080"); err != nil {
		panic(err)
	}
}
```

之后的代码：
```go
package main

import (
	"github.com/gin-gonic/gin"
	"github.com/go_projects/vblog/apps/token"
	"github.com/go_projects/vblog/apps/token/api"
	"github.com/go_projects/vblog/conf"
	"github.com/go_projects/vblog/ioc"

	// 通过import方法 完成注册
	_ "github.com/go_projects/vblog/apps/token/api"
	_ "github.com/go_projects/vblog/apps/token/impl"
	_ "github.com/go_projects/vblog/apps/user/impl"
)

func main() {

	// 1. 初始化程序配置，这里没有配置，使用默认值
	if err := conf.LoadFromEnv(); err != nil {
		panic(err)
	}

	// 2. 程序对象管理
	if err := ioc.Init(); err != nil {
		panic(err)
	}

	// Protocol
	engine := gin.Default()

	rr := engine.Group("/vblog/api/v1")

	// ioc能不能帮忙把模块Api的注册页一起管理
	// ioc.Init()，对象初始化完成后，如果对象是 api对象，就帮忙完成下注册
	// ioc.RegistryGin(rr)？ 就是ioc里执行这个操作
	ioc.Api().Get(token.AppName).(*api.TokenApiHandler).Registry(rr)

	// 把Http协议服务器启动起来
	if err := engine.Run(":8080"); err != nil {
		panic(err)
	}
}

```

## ioc 通用功能管理（切面管理）

```go
type GinApi interface {
	// 基础约束
	Object
	// 额外约束
	// ioc.Api().Get(token.AppName).(*api.TokenApiHandler).Registry(rr)
	Registry(rr gin.IRouter)
}

// 遍历所有的对象，帮忙完成Api的注册
// 由ioc调用对象提供的Registry方法，来把模块的api 注册给gin root router
func (c *NamespaceContainer) RegistryGinApi(rr gin.IRouter) {
	// 遍历Namespace
	for key := range c.ns {
		c := c.ns[key]
		// 遍历Namespace里面的对象
		for objectName := range c.storage {
			obj := c.storage[objectName]
			// 如果判断一个对象不是GinApi对象（约束）
			// 判断对象有没有Registry(rr gin.IRouter)
			// 断言该对象 满足GinApi接口，实现了Registry函数
			if v, ok := obj.(GinApi); ok {
				v.Registry(rr)
			}
		}
	}
}
```

改造后，我们只需要完成业务对象注册，其他操作，ioc帮忙进行管理
```go
func main() {

	// 1. 初始化程序配置，这里没有配置，使用默认值
	if err := conf.LoadFromEnv(); err != nil {
		panic(err)
	}

	// 2.1 先注册对象


	// 2.2 程序对象管理
	if err := ioc.Init(); err != nil {
		panic(err)
	}

	/* v2版，这里都不要了
	// user service impl
	usvc := user_impl.NewUserServiceImpl()

	// token service impl
    tsvc := token_impl.NewTokenServiceImpl(usvc)

	// api
	TokenApiHandler := api.NewTokenApiHandler(tsvc)
	*/

	// Protocol
	engine := gin.Default()

	rr := engine.Group("/vblog/api/v1")
	// 改造之前：TokenApiHandler.Registry(rr)
	// 改造之后第一版：ioc.Api().Get(token.AppName).(*api.TokenApiHandler).Registry(rr)
	ioc.RegistryGinApi(rr)

	// 把Http协议服务器启动起来
	if err := engine.Run(":8080"); err != nil {
		panic(err)
	}
}
```

+ 1. 注册对象
+ 2. ioc管理

通过 导入 "github.com/go_projects/vblog/apps" 来导入所有的业务实现
```go
package apps

// 注册业务实现：API + Controller
// 像插件一样可以替换
import (
	// 通过import方法 完成注册
	_ "github.com/go_projects/vblog/apps/token/api"
	_ "github.com/go_projects/vblog/apps/token/impl"
	_ "github.com/go_projects/vblog/apps/user/impl"
)
```

入口就不需要修改：
```go
package main

import (
	"github.com/gin-gonic/gin"
	"github.com/go_projects/vblog/conf"
	"github.com/go_projects/vblog/ioc"	

	// 通过import方法 完成注册
	// 这样写，就不用再动main这里的代码了。将注册放到apps包下的init.go文件中
	_ "github.com/go_projects/vblog/apps"
)

func main() {

	// 1. 初始化程序配置，这里没有配置，使用默认值
	if err := conf.LoadFromEnv(); err != nil {
		panic(err)
	}

	// 2.1 先注册对象


	// 2.2 程序对象管理
	if err := ioc.Init(); err != nil {
		panic(err)
	}

	/* v2版，这里都不要了
	// user service impl
	usvc := user_impl.NewUserServiceImpl()

	// token service impl
    tsvc := token_impl.NewTokenServiceImpl(usvc)

	// api
	TokenApiHandler := api.NewTokenApiHandler(tsvc)
	*/

	// Protocol
	engine := gin.Default()

	rr := engine.Group("/vblog/api/v1")
	// 改造之前：TokenApiHandler.Registry(rr)
	// 改造之后第一版：ioc.Api().Get(token.AppName).(*api.TokenApiHandler).Registry(rr)
	ioc.RegistryGinApi(rr)

	// 把Http协议服务器启动起来
	if err := engine.Run(":8080"); err != nil {
		panic(err)
	}
}

```

有了iod后，我们业务开发流程，编写：
+ api对象
+ contriller对象

基于这个逻辑开始编写blog模块

## 基于ioc blog模块

### 定义blog业务（Define）

```go
// Blog Service接口定义，CRUD
type Service interface {
	// 创建一个博客
	CreateBlog(context.Context, *CreateBlogRequest) (*Blog, error)
	// 获取博客列表
	QueryBlog(context.Context, *QueryBlogRequest) (*BlogSet, error)
	// 获取博客详情
	DescribeBlog(context.Context, *DescribeBlogReqeust) (*Blog, error)
	// 更新博客
	UpdateBlog(context.Context, *UpdateBlogRequest) (*Blog, error)
	// 删除博客
	// 为了与GRPC保持一致，返回一个删除的对象
	DeleteBlog(context.Context, *DeleteBlogReqeust) (*Blog, error)
	// 文章状态修改，比如发布
	ChangedBlogStatus(context.Context, *ChangedBlogStatus) (*Blog, error)
	// 文章审核
	AuditBlog(context.Context, *AuditInfo) (*Blog, error)
}
```

### 实现业务（Controller）

### 暴露接口（API）

### 注册业务对象





